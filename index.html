<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Workflow Visualizer</title>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #ffffff, #f0f4f8, #e0e7ff);
            color: #333333;
            margin: 0;
            padding: 20px;
            display: flex;
        }
        #main-content { flex: 1; }
        #diagram { margin-bottom: 20px; overflow: auto; }
        #git-svg {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #4ade80, #22c55e);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.3);
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.5);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #ffffff, #f0f4f8);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            width: 80%;
            max-width: 400px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            color: #333333;
        }
        .close {
            color: #888;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover, .close:focus {
            color: #333;
            text-decoration: none;
            cursor: pointer;
        }
        input[type="text"], textarea, select {
            padding: 10px;
            margin: 10px 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            color: #333;
        }
        input[type="text"]::placeholder { color: rgba(0, 0, 0, 0.5); }
        input[type="file"] { color: #333; }
        h1 {
            text-align: center;
            color: #22c55e;
            text-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        p { text-align: center; color: #666; }
        #sidebar {
            width: 300px;
            background-color: #ffffff;
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            display: none;
            flex-direction: column;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.05);
        }
        #sidebar h2 { margin-top: 0; }
        #sidebar button { margin-top: 10px; }
        #delete-node, #delete-branch {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        #delete-node:hover, #delete-branch:hover {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.5);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div id="main-content">
        <h1>Git Workflow Visualizer</h1>
        <p>Based on the provided Git Workflow image. Start with Main branch, add custom branches and nodes via modals. Hover on branch lines to see ghost node at grid positions, click to add node there.</p>
       
        <div id="diagram">
            <svg id="git-svg"></svg> <!-- Height and width dynamic -->
        </div>
       
        <div class="controls">
            <button onclick="openAddBranchModal()">Add Branch</button>
            <button onclick="downloadCSV()">Download CSV</button>
            <input type="file" id="upload" accept=".csv" onchange="uploadCSV()">
        </div>
    </div>
   
    <!-- Sidebar -->
    <div id="sidebar">
        <h2>Node Details</h2>
        <label for="node-title">Title:</label>
        <input id="node-title" type="text">
        <label for="node-content">Content:</label>
        <textarea id="node-content" rows="5"></textarea>
        <button onclick="saveNodeDetails()">Save</button>
        <button id="delete-node" onclick="deleteNode()">Delete Node</button>
        <button id="delete-branch" onclick="deleteBranch()">Delete Branch</button>
        <button onclick="closeSidebar()">Close</button>
    </div>
   
    <!-- Add Branch Modal -->
    <div id="addBranchModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addBranchModal')">&times;</span>
            <h2>Add New Branch</h2>
            <input id="new-branch-name" type="text" placeholder="Branch name">
            <input id="new-branch-color" type="text" placeholder="Color (e.g., #ffa07a)">
            <button onclick="addBranch()">Create Branch</button>
        </div>
    </div>
   
    <!-- Add Node Modal -->
    <div id="addNodeModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('addNodeModal')">&times;</span>
            <h2>Add New Node</h2>
            <input id="node-message" type="text" placeholder="Commit message (Title)">
            <textarea id="node-content-new" rows="5" placeholder="Content"></textarea>
            <button onclick="addNodeFromModal()">Create Node</button>
        </div>
    </div>
   
    <script>
        let branches = { Main: { y: 100, color: '#add8e6', nodes: [] } };
        let connections = [];
        const startX = 100;
        const nodeRadius = 10;
        const gridSpacing = 50;
        const ySpacing = 50;
        const minNodeX = startX + 100;
        let maxNodeX = 1100;
        const minBranchY = 100;
        const minBranchDistance = 20;
        const extensionAmount = 500;
        const hoverTolerance = 5;
        const svg = document.getElementById('git-svg');
        let selectedBranchForNode = null;
        let selectedXForNode = null;
        let ghostCircle = null;
        let ghostBranchLine = null;
        let ghostExtension = null;
        let ghostLine = null;
        let pendingY = null;
        let editingLabel = null;
        let currentSelectedNode = null;
        let selectedConnection = null;
        let isDragging = false;
        let dragNode = null;
        let isAdding = false;
        let fromNode = null;
        let currentTargetBranch = null;
        function getSvgPoint(e) {
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }
        function snapToXGrid(x) {
            x = Math.max(minNodeX, Math.min(maxNodeX, x));
            return Math.round((x - minNodeX) / gridSpacing) * gridSpacing + minNodeX;
        }
        function snapToYGrid(y) {
            y = Math.max(minBranchY, y);
            return Math.round((y - minBranchY) / gridSpacing) * gridSpacing + minBranchY;
        }
        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        function openAddBranchModal() {
            openModal('addBranchModal');
            removeGhostBranch();
        }
        function openAddNodeModal(branchName, xPos) {
            selectedBranchForNode = branchName;
            selectedXForNode = xPos;
            openModal('addNodeModal');
            removeGhost();
        }
        function addBranch() {
            const name = document.getElementById('new-branch-name').value.trim();
            let color = document.getElementById('new-branch-color').value.trim() || getRandomColor();
            if (!name || branches[name]) {
                alert('Invalid or duplicate branch name');
                return;
            }
            const maxY = Object.keys(branches).length > 0 ? Math.max(...Object.values(branches).map(b => b.y)) : minBranchY;
            const y = pendingY ?? (maxY + ySpacing);
            pendingY = null;
            branches[name] = { y, color, nodes: [] };
            drawDiagram();
            closeModal('addBranchModal');
            document.getElementById('new-branch-name').value = '';
            document.getElementById('new-branch-color').value = '';
        }
        function addNodeFromModal() {
            if (!selectedBranchForNode) return;
            const title = document.getElementById('node-message').value || 'New commit';
            const content = document.getElementById('node-content-new').value || '';
            const branch = branches[selectedBranchForNode];
            const existing = branch.nodes.some(node => node.x === selectedXForNode);
            if (existing) {
                alert('Position already occupied by a node.');
                return;
            }
            if (selectedXForNode > maxNodeX) {
                maxNodeX = selectedXForNode + gridSpacing;
            }
            branch.nodes.push({ x: selectedXForNode, title, content });
            branch.nodes.sort((a, b) => a.x - b.x);
            drawDiagram();
            closeModal('addNodeModal');
            document.getElementById('node-message').value = '';
            document.getElementById('node-content-new').value = '';
            selectedBranchForNode = null;
            selectedXForNode = null;
        }
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
        function drawDiagram() {
            svg.innerHTML = '';
            const maxY = Object.keys(branches).length > 0 ? Math.max(...Object.values(branches).map(b => b.y)) : minBranchY;
            const svgHeight = maxY + 200;
            const svgWidth = maxNodeX + 100;
            svg.setAttribute('width', svgWidth);
            svg.setAttribute('height', svgHeight);
            for (let x = minNodeX; x <= maxNodeX; x += gridSpacing) {
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', x);
                gridLine.setAttribute('y1', 50);
                gridLine.setAttribute('x2', x);
                gridLine.setAttribute('y2', svgHeight);
                gridLine.setAttribute('stroke', '#d3d3d3');
                gridLine.setAttribute('stroke-width', 1);
                svg.appendChild(gridLine);
            }
            for (let y = minBranchY; y <= maxY + ySpacing; y += gridSpacing) {
                const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                gridLine.setAttribute('x1', startX + 50);
                gridLine.setAttribute('y1', y);
                gridLine.setAttribute('x2', maxNodeX);
                gridLine.setAttribute('y2', y);
                gridLine.setAttribute('stroke', '#d3d3d3');
                gridLine.setAttribute('stroke-width', 1);
                svg.appendChild(gridLine);
            }
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            arrow.setAttribute('x1', 50);
            arrow.setAttribute('y1', 50);
            arrow.setAttribute('x2', maxNodeX + 50);
            arrow.setAttribute('y2', 50);
            arrow.setAttribute('stroke', '#333333');
            arrow.setAttribute('stroke-width', 2);
            arrow.setAttribute('marker-end', 'url(#arrowhead)');
            svg.appendChild(arrow);
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('viewBox', '0 -5 10 10');
            marker.setAttribute('refX', 10);
            marker.setAttribute('refY', 0);
            marker.setAttribute('markerWidth', 6);
            marker.setAttribute('markerHeight', 6);
            marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,-5L10,0L0,5');
            path.setAttribute('fill', '#333333');
            marker.appendChild(path);
            defs.appendChild(marker);
            svg.appendChild(defs);
            const timeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            timeText.setAttribute('x', 50);
            timeText.setAttribute('y', 40);
            timeText.setAttribute('fill', '#333333');
            timeText.textContent = 'TIME →';
            svg.appendChild(timeText);
            const extensionHit = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            extensionHit.setAttribute('x', maxNodeX - 50);
            extensionHit.setAttribute('y', 30);
            extensionHit.setAttribute('width', 100);
            extensionHit.setAttribute('height', 40);
            extensionHit.setAttribute('fill', 'transparent');
            extensionHit.addEventListener('mousemove', () => {
                if (!ghostExtension) {
                    ghostExtension = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    ghostExtension.setAttribute('x1', maxNodeX);
                    ghostExtension.setAttribute('y1', 50);
                    ghostExtension.setAttribute('x2', maxNodeX + extensionAmount);
                    ghostExtension.setAttribute('y2', 50);
                    ghostExtension.setAttribute('stroke', '#333333');
                    ghostExtension.setAttribute('stroke-width', 2);
                    ghostExtension.setAttribute('opacity', 0.5);
                    svg.appendChild(ghostExtension);
                }
            });
            extensionHit.addEventListener('mouseleave', () => {
                if (ghostExtension) {
                    svg.removeChild(ghostExtension);
                    ghostExtension = null;
                }
            });
            extensionHit.addEventListener('click', () => {
                maxNodeX += extensionAmount;
                drawDiagram();
            });
            svg.appendChild(extensionHit);
            connections.forEach((conn, connIndex) => {
                const fromBranch = branches[conn.fromBranch];
                const toBranch = branches[conn.toBranch];
                const fromNode = fromBranch.nodes[conn.fromNodeIndex];
                const toNode = toBranch.nodes[conn.toNodeIndex];
                if (fromNode && toNode) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('id', `conn-${connIndex}`);
                    line.setAttribute('x1', fromNode.x);
                    line.setAttribute('y1', fromBranch.y);
                    line.setAttribute('x2', toNode.x);
                    line.setAttribute('y2', toBranch.y);
                    line.setAttribute('stroke', '#808080');
                    line.setAttribute('stroke-width', 2);
                    line.addEventListener('click', () => deleteConnection(connIndex));
                    svg.appendChild(line);
                }
            });
            const sortedBranches = Object.entries(branches).sort((a, b) => a[1].y - b[1].y);
            sortedBranches.forEach(([branchName, branch]) => {
                const labelRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                labelRect.setAttribute('x', startX - 40);
                labelRect.setAttribute('y', branch.y - 15);
                labelRect.setAttribute('width', 80);
                labelRect.setAttribute('height', 30);
                labelRect.setAttribute('fill', branch.color);
                labelRect.setAttribute('rx', 5);
                svg.appendChild(labelRect);
                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', startX);
                labelText.setAttribute('y', branch.y + 5);
                labelText.setAttribute('fill', 'black');
                labelText.setAttribute('text-anchor', 'middle');
                labelText.textContent = branchName;
                labelText.addEventListener('dblclick', () => editBranchLabel(branchName, labelText));
                svg.appendChild(labelText);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX + 50);
                line.setAttribute('y1', branch.y);
                line.setAttribute('x2', maxNodeX);
                line.setAttribute('y2', branch.y);
                line.setAttribute('stroke', '#808080');
                line.setAttribute('stroke-width', 1);
                line.setAttribute('stroke-dasharray', '5,5');
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                hitArea.setAttribute('x1', startX + 50);
                hitArea.setAttribute('y1', branch.y);
                hitArea.setAttribute('x2', maxNodeX);
                hitArea.setAttribute('y2', branch.y);
                hitArea.setAttribute('stroke', 'transparent');
                hitArea.setAttribute('stroke-width', 20);
                hitArea.addEventListener('mousemove', (e) => {
                    let {x: rawX, y: rawY} = getSvgPoint(e);
                    let snappedX = snapToXGrid(rawX);
                    let snappedY = snapToYGrid(rawY);
                    if (Math.abs(rawX - snappedX) > hoverTolerance || Math.abs(rawY - snappedY) > hoverTolerance || snappedX < minNodeX || snappedX > maxNodeX) {
                        removeGhost();
                        return;
                    }
                    const occupied = branch.nodes.some(node => node.x === snappedX);
                    if (occupied) {
                        removeGhost();
                        return;
                    }
                    if (!ghostCircle) {
                        ghostCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        ghostCircle.setAttribute('r', nodeRadius);
                        ghostCircle.setAttribute('fill', branch.color);
                        ghostCircle.setAttribute('opacity', 0.5);
                        svg.appendChild(ghostCircle);
                    }
                    ghostCircle.setAttribute('cx', snappedX);
                    ghostCircle.setAttribute('cy', branch.y);
                });
                hitArea.addEventListener('mouseleave', removeGhost);
                hitArea.addEventListener('click', (e) => {
                    let {x: rawX, y: rawY} = getSvgPoint(e);
                    let snappedX = snapToXGrid(rawX);
                    let snappedY = snapToYGrid(rawY);
                    if (Math.abs(rawX - snappedX) > hoverTolerance || Math.abs(rawY - snappedY) > hoverTolerance) return;
                    const occupied = branch.nodes.some(node => node.x === snappedX);
                    if (!occupied && snappedX >= minNodeX && snappedX <= maxNodeX) {
                        openAddNodeModal(branchName, snappedX);
                    }
                    e.stopPropagation();
                });
                svg.appendChild(line);
                svg.appendChild(hitArea);
                branch.nodes.forEach((node, index) => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.setAttribute('class', 'node-group');
                    group.addEventListener('mouseenter', () => {
                        if (isAdding || isDragging) return;
                        const minus = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        minus.setAttribute('x', node.x - 20);
                        minus.setAttribute('y', branch.y + 5);
                        minus.setAttribute('fill', 'red');
                        minus.setAttribute('font-size', '20');
                        minus.setAttribute('class', 'node-icon');
                        minus.textContent = '-';
                        minus.addEventListener('click', (e) => {
                            branches[branchName].nodes.splice(index, 1);
                            connections = connections.filter(conn => !(conn.fromBranch === branchName && conn.fromNodeIndex === index) && !(conn.toBranch === branchName && conn.toNodeIndex === index));
                            connections.forEach(conn => {
                                if (conn.fromBranch === branchName && conn.fromNodeIndex > index) conn.fromNodeIndex--;
                                if (conn.toBranch === branchName && conn.toNodeIndex > index) conn.toNodeIndex--;
                            });
                            drawDiagram();
                            e.stopPropagation();
                        });
                        group.appendChild(minus);
                        const plus = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        plus.setAttribute('x', node.x + 10);
                        plus.setAttribute('y', branch.y + 5);
                        plus.setAttribute('fill', 'green');
                        plus.setAttribute('font-size', '20');
                        plus.setAttribute('class', 'node-icon');
                        plus.textContent = '+';
                        plus.addEventListener('click', (e) => {
                            isAdding = true;
                            fromNode = {branchName, index, x: node.x, y: branch.y};
                            const icons = group.querySelectorAll('.node-icon');
                            icons.forEach(icon => group.removeChild(icon));
                            e.stopPropagation();
                        });
                        group.appendChild(plus);
                    });
                    group.addEventListener('mouseleave', () => {
                        const icons = group.querySelectorAll('.node-icon');
                        icons.forEach(icon => group.removeChild(icon));
                    });
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('id', `node-circle-${branchName.replace(/ /g, '_')}-${index}`);
                    circle.setAttribute('cx', node.x);
                    circle.setAttribute('cy', branch.y);
                    circle.setAttribute('r', nodeRadius);
                    circle.setAttribute('fill', branch.color);
                    circle.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        const currentX = branch.nodes[index].x;
                        let leftX = minNodeX - gridSpacing;
                        let rightX = maxNodeX + gridSpacing;
                        branch.nodes.forEach((n, i) => {
                            if (i !== index) {
                                if (n.x < currentX) leftX = Math.max(leftX, n.x);
                                else if (n.x > currentX) rightX = Math.min(rightX, n.x);
                            }
                        });
                        const minDragX = leftX + gridSpacing;
                        const maxDragX = rightX - gridSpacing;
                        dragNode = {
                            branchName,
                            nodeIndex: index,
                            node: branch.nodes[index],
                            minDragX,
                            maxDragX,
                            startX: currentX
                        };
                        e.stopPropagation();
                    });
                    circle.addEventListener('dblclick', (e) => {
                        showSidebar(branchName, index);
                        e.stopPropagation();
                    });
                    group.appendChild(circle);
                    const nodeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    nodeText.setAttribute('id', `node-text-${branchName.replace(/ /g, '_')}-${index}`);
                    nodeText.setAttribute('x', node.x);
                    nodeText.setAttribute('y', branch.y + 25);
                    nodeText.setAttribute('fill', '#333333');
                    nodeText.setAttribute('text-anchor', 'middle');
                    nodeText.textContent = (node.title || 'Untitled').substring(0, 10) + '...';
                    group.appendChild(nodeText);
                    svg.appendChild(group);
                });
            });
        }
        function editBranchLabel(oldName, textElement) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = oldName;
            input.style.position = 'absolute';
            input.style.left = textElement.getBoundingClientRect().left + 'px';
            input.style.top = textElement.getBoundingClientRect().top + 'px';
            input.style.width = '80px';
            input.style.textAlign = 'center';
            document.body.appendChild(input);
            input.focus();
            input.addEventListener('blur', () => {
                const newName = input.value.trim();
                if (newName && newName !== oldName && !branches[newName]) {
                    branches[newName] = branches[oldName];
                    delete branches[oldName];
                    connections.forEach(conn => {
                        if (conn.fromBranch === oldName) conn.fromBranch = newName;
                        if (conn.toBranch === oldName) conn.toBranch = newName;
                    });
                    drawDiagram();
                }
                document.body.removeChild(input);
            });
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') input.blur(); });
        }
        function showSidebar(branchName, nodeIndex) {
            currentSelectedNode = {branchName, nodeIndex};
            const node = branches[branchName].nodes[nodeIndex];
            document.getElementById('node-title').value = node.title || '';
            document.getElementById('node-content').value = node.content || '';
            document.getElementById('sidebar').style.display = 'flex';
        }
        function saveNodeDetails() {
            if (!currentSelectedNode) return;
            const {branchName, nodeIndex} = currentSelectedNode;
            const node = branches[branchName].nodes[nodeIndex];
            node.title = document.getElementById('node-title').value;
            node.content = document.getElementById('node-content').value;
            drawDiagram();
            closeSidebar();
        }
        function deleteNode() {
            if (!currentSelectedNode) return;
            const {branchName, nodeIndex} = currentSelectedNode;
            branches[branchName].nodes.splice(nodeIndex, 1);
            connections = connections.filter(conn => !(conn.fromBranch === branchName && conn.fromNodeIndex === nodeIndex) && !(conn.toBranch === branchName && conn.toNodeIndex === nodeIndex));
            connections.forEach(conn => {
                if (conn.fromBranch === branchName && conn.fromNodeIndex > nodeIndex) conn.fromNodeIndex--;
                if (conn.toBranch === branchName && conn.toNodeIndex > nodeIndex) conn.toNodeIndex--;
            });
            drawDiagram();
            closeSidebar();
        }
        function deleteBranch() {
            if (!currentSelectedNode) return;
            const {branchName} = currentSelectedNode;
            if (confirm('Delete this branch and all its nodes?')) {
                delete branches[branchName];
                connections = connections.filter(conn => conn.fromBranch !== branchName && conn.toBranch !== branchName);
                drawDiagram();
                closeSidebar();
            }
        }
        function deleteConnection(connIndex) {
            if (confirm('Delete this connection?')) {
                connections.splice(connIndex, 1);
                drawDiagram();
            }
        }
        function closeSidebar() {
            document.getElementById('sidebar').style.display = 'none';
            currentSelectedNode = null;
        }
        function removeGhost() {
            if (ghostCircle) {
                svg.removeChild(ghostCircle);
                ghostCircle = null;
            }
            if (ghostLine) {
                svg.removeChild(ghostLine);
                ghostLine = null;
            }
        }
        function removeGhostBranch() {
            if (ghostBranchLine) {
                svg.removeChild(ghostBranchLine);
                ghostBranchLine = null;
            }
        }
        function downloadCSV() {
            let csvContent = 'type,branch,y,color,x,title,content,fromBranch,fromNodeIndex,toBranch,toNodeIndex\n';
            Object.keys(branches).forEach(branchName => {
                const branch = branches[branchName];
                csvContent += `branch,${branchName},${branch.y},${branch.color},,,, , , ,\n`;
                branch.nodes.forEach(node => {
                    csvContent += `node,${branchName}, , ,${node.x},${node.title},${node.content}, , , ,\n`;
                });
            });
            connections.forEach(conn => {
                csvContent += `connection, , , , , , ,${conn.fromBranch},${conn.fromNodeIndex},${conn.toBranch},${conn.toNodeIndex}\n`;
            });
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'git_workflow.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        function uploadCSV() {
            const file = document.getElementById('upload').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    const lines = text.split('\n').slice(1);
                    branches = {};
                    connections = [];
                    lines.forEach(line => {
                        if (line.trim()) {
                            const [type, branch, y, color, x, title, content, fromBranch, fromNodeIndex, toBranch, toNodeIndex] = line.split(',');
                            if (type === 'branch') {
                                branches[branch] = { y: parseInt(y), color, nodes: [] };
                            } else if (type === 'node') {
                                if (branches[branch]) {
                                    branches[branch].nodes.push({ x: parseInt(x), title, content });
                                }
                            } else if (type === 'connection') {
                                connections.push({ fromBranch, fromNodeIndex: parseInt(fromNodeIndex), toBranch, toNodeIndex: parseInt(toNodeIndex) });
                            }
                        }
                    });
                    Object.keys(branches).forEach(b => {
                        branches[b].nodes.sort((a, b) => a.x - b.x);
                    });
                    if (Object.keys(branches).length === 0) {
                        branches.Main = { y: 100, color: '#add8e6', nodes: [] };
                    }
                    let newMaxX = 1100;
                    Object.values(branches).forEach(b => {
                        b.nodes.forEach(n => {
                            if (n.x > newMaxX) newMaxX = n.x;
                        });
                    });
                    maxNodeX = newMaxX + gridSpacing;
                    drawDiagram();
                };
                reader.readAsText(file);
            }
        }
        drawDiagram();
        svg.addEventListener('mousemove', (e) => {
            const {x: rawX, y: rawY} = getSvgPoint(e);
            if (isAdding) {
                let closestBranch = null;
                let minDist = Infinity;
                currentTargetBranch = null;
                Object.entries(branches).forEach(([bName, b]) => {
                    let dist = Math.abs(b.y - rawY);
                    if (dist < minDist) {
                        minDist = dist;
                        closestBranch = {name: bName, y: b.y, branch: b};
                    }
                });
                if (minDist > 20) {
                    removeGhost();
                    return;
                }
                currentTargetBranch = closestBranch.name;
                let snappedX = snapToXGrid(rawX);
                if (snappedX <= fromNode.x || snappedX < minNodeX || snappedX > maxNodeX) {
                    removeGhost();
                    return;
                }
                const occupied = closestBranch.branch.nodes.some(n => n.x === snappedX);
                if (occupied) {
                    removeGhost();
                    return;
                }
                if (!ghostCircle) {
                    ghostCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    ghostCircle.setAttribute('r', nodeRadius);
                    ghostCircle.setAttribute('opacity', 0.5);
                    svg.appendChild(ghostCircle);
                }
                ghostCircle.setAttribute('cx', snappedX);
                ghostCircle.setAttribute('cy', closestBranch.y);
                ghostCircle.setAttribute('fill', closestBranch.branch.color);
                if (!ghostLine) {
                    ghostLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    ghostLine.setAttribute('stroke', '#808080');
                    ghostLine.setAttribute('stroke-width', 2);
                    ghostLine.setAttribute('opacity', 0.5);
                    svg.appendChild(ghostLine);
                }
                ghostLine.setAttribute('x1', fromNode.x);
                ghostLine.setAttribute('y1', fromNode.y);
                ghostLine.setAttribute('x2', snappedX);
                ghostLine.setAttribute('y2', closestBranch.y);
            } else {
                let snappedY = snapToYGrid(rawY);
                if (Math.abs(rawY - snappedY) > hoverTolerance) {
                    removeGhostBranch();
                    return;
                }
                const isNearExisting = Object.values(branches).some(b => Math.abs(b.y - snappedY) < minBranchDistance);
                if (isNearExisting || snappedY < minBranchY || rawX < startX + 50 || rawX > maxNodeX) {
                    removeGhostBranch();
                    return;
                }
                if (!ghostBranchLine) {
                    ghostBranchLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    ghostBranchLine.setAttribute('x1', startX + 50);
                    ghostBranchLine.setAttribute('x2', maxNodeX);
                    ghostBranchLine.setAttribute('stroke', '#808080');
                    ghostBranchLine.setAttribute('stroke-width', 1);
                    ghostBranchLine.setAttribute('stroke-dasharray', '5,5');
                    ghostBranchLine.setAttribute('opacity', 0.5);
                    svg.appendChild(ghostBranchLine);
                }
                ghostBranchLine.setAttribute('y1', snappedY);
                ghostBranchLine.setAttribute('y2', snappedY);
            }
            if (isDragging) {
                let snappedX = snapToXGrid(rawX);
                snappedX = Math.max(dragNode.minDragX, Math.min(dragNode.maxDragX, snappedX));
                if (snappedX === dragNode.node.x) return;
                dragNode.node.x = snappedX;
                const safeBranchName = dragNode.branchName.replace(/ /g, '_');
                const circleId = `node-circle-${safeBranchName}-${dragNode.nodeIndex}`;
                const textId = `node-text-${safeBranchName}-${dragNode.nodeIndex}`;
                document.getElementById(circleId).setAttribute('cx', snappedX);
                document.getElementById(textId).setAttribute('x', snappedX);
                connections.forEach((conn, connIndex) => {
                    const lineId = `conn-${connIndex}`;
                    if (conn.fromBranch === dragNode.branchName && conn.fromNodeIndex === dragNode.nodeIndex) {
                        document.getElementById(lineId).setAttribute('x1', snappedX);
                    }
                    if (conn.toBranch === dragNode.branchName && conn.toNodeIndex === dragNode.nodeIndex) {
                        document.getElementById(lineId).setAttribute('x2', snappedX);
                    }
                });
            }
        });
        svg.addEventListener('mouseup', () => {
            isDragging = false;
            dragNode = null;
        });
        svg.addEventListener('mouseleave', () => {
            removeGhostBranch();
            if (isAdding) removeGhost();
        });
        svg.addEventListener('click', (e) => {
            const {x: rawX, y: rawY} = getSvgPoint(e);
            if (isAdding && ghostCircle) {
                const title = 'New commit';
                const content = '';
                const branch = branches[currentTargetBranch];
                const newX = parseFloat(ghostCircle.getAttribute('cx'));
                if (newX > maxNodeX) {
                    maxNodeX = newX + gridSpacing;
                }
                branch.nodes.push({ x: newX, title, content });
                branch.nodes.sort((a, b) => a.x - b.x);
                const newNodeIndex = branch.nodes.findIndex(n => n.x === newX);
                connections.push({
                    fromBranch: fromNode.branchName,
                    fromNodeIndex: fromNode.index,
                    toBranch: currentTargetBranch,
                    toNodeIndex: newNodeIndex
                });
                isAdding = false;
                fromNode = null;
                currentTargetBranch = null;
                removeGhost();
                drawDiagram();
                e.stopPropagation();
                return;
            }
            if (rawX < startX + 50 || rawX > maxNodeX) return;
            let snappedY = snapToYGrid(rawY);
            if (Math.abs(rawY - snappedY) > hoverTolerance) return;
            const isNearExisting = Object.values(branches).some(b => Math.abs(b.y - snappedY) < minBranchDistance);
            if (!isNearExisting && snappedY >= minBranchY) {
                pendingY = snappedY;
                openAddBranchModal();
            }
        });
    </script>
</body>
</html>
